/*[]-----------------------------------------------------------------[]*/
/*|           					FIRESNAKE	                          |*/
/*|*******************************************************************|*/
/*|  Disciplina.......: Linguagens Formais e Tradutores      	      |*/
/*|  Data........: 18/12/2018								          |*/
/*|  @Aluno......: Jefferson  Santos  e Igor Terriaga                 |*/
/*|  Info........: FireSnake é um compilador para o reconhecimento    |*/
/*|   			   da linguagem Python. 							  |*/
/*[]-----------------------------------------------------------------[]*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
	private Symbol s;
	public void sintax_error(Symbol s){
		this.s  = s;	
	}
	public Symbol getS (){
		return this.s;
	}


:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

                    /********** TERMINALS OPERATORS AND DELIMITERS *********/
terminal            SEMI, PLUS, MINUS, UMINUS, TIMES,DIVISION, EQUAL;

terminal 			EQUALTWO,NOTSAME,BIGGER,SMALLER,GREATEREQUAL,LESSEQUAL;

terminal			LPAREN,RPAREN,L_BRACKET,R_BRACKET,L_KEY,R_KEY;

terminal            COLON_OP,COMMA,SCORE,SEMICOLON;


                    /********** RESERVED WORDS  *********/
terminal            FALSE,TRUE,RETURN,DEF,FOR,WHILE,GLOBAL, NOT,ELIF,IF,ELSE, IN, RANGE, IDENT, DEDENT,OR,AND;

                    /********** ANOTHER WORDS  *********/
terminal            INTEGER_LITERAL;  
terminal            NUMBERFLOAT_LITERAL;
terminal            IDENTIFIER,RESERVED_WORDS;
terminal            COMENTARIOS, COMENTARIO;

       			/* ********** STRINGS ********* */

terminal            STRING;
     
					 /********** NO TERMINAIS  *********/
non terminal            expr_list, number_aux,fim,fun_stmt;
non terminal            expr,exprS,bool_posible,list_params_logicos,comando,expr1,block_stm,stms;      // used to store evaluated subexpressions
non terminal            atrib,while,if,for,arith_op,logic_op,func_def,list_params,list_params_a;
non terminal            Y,T,F,O,K,P,operadores_logicos,precedence_logic,list_argumentos,par_expr,def_funcao_stmt,aux_vetor;
non terminal            Comandos,return_stmt, else_stmt,elif_stmt,vetor,equilibrio_parenteses,while_expr,expr2,if_expr,for_expr,R,for_stmt,range_stmt,range_values,bracket_expr;



					 /********** PRECEDENCES  *********/
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVISION;

					 /********** GENERATION GRAMMAR MODEL  *********/     
             
         						/*Nossa Gramática para o Python*/    
         						//Expression Statement

start with comando;

comando  ::=  atrib
		|
		 while_expr
		|
		 if_expr
		|
		 fun_stmt 
		|
		 vetor
		;
Comandos ::= comando
		|
		Comandos comando
		;
expr ::= logic_op
		;
		
return_stmt ::= RETURN expr
		;
		
atrib   ::= IDENTIFIER EQUAL expr
		;

fun_stmt        ::= DEF IDENTIFIER LPAREN list_params RPAREN COLON_OP IDENT comando DEDENT
					|
					DEF IDENTIFIER LPAREN RPAREN COLON_OP comando
					|
					error {:System.err.println(" Erro na definição da função \n");:}
					;

list_params ::= IDENTIFIER  list_params_a
				|
				IDENTIFIER
				;
list_params_a ::=  COMMA IDENTIFIER list_params_a				
				;
					
number_aux ::=  INTEGER_LITERAL
				|
				NUMBERFLOAT_LITERAL
				;
arith_op ::=  arith_op PLUS T
				|
			  arith_op MINUS T
			  	|
			  	T
				;
T        ::=   T TIMES F
			   |
			   T DIVISION F
			   |
			   Y
			   ;
Y ::= 			number_aux
				|
				IDENTIFIER
				|
				bool_posible
				|
				STRING
				;
	 	 
logic_op ::=  	 arith_op  precedence_logic arith_op 
				;
bool_posible ::= TRUE
				|
				FALSE
				;

precedence_logic ::= precedence_logic OR O
					|
					precedence_logic AND O
					|
					O
					;
O                ::= O NOT K
					|
					K
					;
K                ::= K SMALLER arith_op
					|
					K LESSEQUAL arith_op
					|
					K BIGGER arith_op
					|
					K GREATEREQUAL arith_op
					|
					K NOTSAME arith_op
					|
					K EQUALTWO arith_op
					|
					arith_op
					;


bracket_expr ::= L_BRACKET list_argumentos R_BRACKET
				|
				par_expr
				;
par_expr     ::= LPAREN list_argumentos RPAREN
				|
				range_values
				;
/*list_argumentos ::= list_argumentos COMMA expr
					|
					expr
				    ;*/

for_stmt      ::= FOR IDENTIFIER IN range_stmt COLON_OP IDENT Comandos DEDENT
				|
				FOR IDENTIFIER IN bracket_expr COLON_OP IDENT Comandos DEDENT
				;
range_stmt    ::= RANGE LPAREN range_values RPAREN
				|
				RANGE LPAREN range_values COMMA range_values RPAREN
				|
				RANGE LPAREN range_values COMMA range_values COMMA range_values RPAREN
				;
range_values  ::= IDENTIFIER
				|
				INTEGER_LITERAL
				
				;
while_expr    ::= WHILE logic_op COLON_OP IDENT Comandos DEDENT
				;
if_expr       ::= IF  logic_op  COLON_OP  IDENT Comandos DEDENT 
				|
				IF  logic_op  COLON_OP IDENT elif_stmt DEDENT
				|
				IF  logic_op  COLON_OP IDENT Comandos else_stmt logic_op DEDENT 
				;
else_stmt     ::= ELSE  IDENT Comandos DEDENT 
				;
elif_stmt     ::= ELIF  logic_op IDENT Comandos DEDENT
				;

aux_vetor ::= aux_vetor COMMA INTEGER_LITERAL
			|
			aux_vetor COMMA STRING
			;

vetor ::= IDENTIFIER EQUAL L_BRACKET R_BRACKET
		|
		IDENTIFIER EQUAL L_BRACKET aux_vetor R_BRACKET
		;